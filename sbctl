#!/bin/ksh

SCRIPTNAME=$0
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:$PATH

OS=$(uname -s)
DashboardBasePort=3001
GatewayBasePort=8081
SCRIPTDIR=$(cd $(dirname $SCRIPTNAME);echo $PWD)
VERSIONFILE=$SCRIPTDIR/tyk-versions.list

# directories shared into all sandboxes to allow for plugins and certs to be installed easily
SandboxPluginDir=~/tyk/plugins
SandboxCertDir=~/tyk/certs

typeset -A GATEWAY
typeset -A DASHBOARD
typeset -A TIB
typeset -A PUMP
typeset -A SYNC

#find the local IP address (use the interface of the default route)
if [[ $OS == "Linux" ]]
then
  default_dev=$(ip route list | sed 's/none //' | awk '/default/ {print $5}')
  IP_addr=$(ip addr show dev $default_dev | awk '$1 == "inet" {print $2}' | head -1 | cut -d/ -f1)
elif [[ $OS == "Darwin" ]]
then
  default_dev=$(netstat -rnf inet | awk '/^default/{print $NF}')
  IP_addr=$(ipconfig getifaddr $default_dev)
fi

function help {
  echo "[USAGE]:"
  echo "$SCRIPTNAME build -l | -v tyk-gateway-version-number [-r image version]"
  echo "        builds a sandbox image for that version if its not already available"
  echo "        -v version to build"
  echo "        -r package revision"
  echo "        -l list versions that images can be made for (incompatible with -v and -r)"
  echo "$SCRIPTNAME create -v tyk-version [-t ticket no] [-i index-number] [-n]"
  echo "        -i index number (skip for autoallocation of the next free)"
  echo "        -n IGNORE ~/.tyk-sandbox even if it exists"
  echo "           You can populate ~/.tyk-sandbox with values to bootstrap the sandbox with:"
  echo "           These will be used when -n is NOT present"
  echo "           TYK_LICENSE=licence string"
  echo "           TYK_USER=user email"
  echo "           TYK_PASSWORD=password"
  echo "        -t ticket or comment field"
  echo "        -v tyk version of sandbox image. Defaults to 'latest'"
  echo "$SCRIPTNAME images"
  echo "        list the docker images for creating sandboxes"
  echo "$SCRIPTNAME list <index number...>"
  echo "        details about the named sandbox or all"
  echo "$SCRIPTNAME script <index number...>"
  echo "        run a shell in the sandboxes named"
  echo "$SCRIPTNAME [start|stop|restart|rm] <index number...>"
  echo "        take the action named on the listed sandboxes"
}

# touch files correspoinding to the versions that need to be installed so that the installer can install them
function touchRPMs {
  typeset version; typeset gwVers; typeset dshbVers; typeset pumpVers
  typeset TIBvers; typeset syncVers; typeset oldFile
  typeset rpmDir="$SCRIPTDIR"/assets/rpms/tyk
  version=$1
  if [[ ${GATEWAY[$version]+_} ]]
  then
    gwVers=${GATEWAY[$version]}
    dshbVers=${DASHBOARD[$gwVers]}
    TIBvers=${TIB[$gwVers]}
    pumpVers=${PUMP[$gwVers]}
    syncVers=${SYNC[$gwVers]}
  else
    echo "[FATAL]Gateway version $version isn't configured $VERSIONFILE"
    exit 1
  fi
  for oldFile in "$rpmDir"/tyk-gateway-* "$rpmDir"/tyk-dashboard-* "$rpmDir"/tyk-pump-* "$rpmDir"/tyk-identity-broker-* "$rpmDir"/tyk-sync-*
  do
    if [[ -f "$oldFile" ]]
    then
      rm -f "$oldFile"
    fi
  done
  touch "$rpmDir/tyk-gateway-$gwVers"
  touch "$rpmDir/tyk-dashboard-$dshbVers"
  touch "$rpmDir/tyk-pump-$pumpVers"
  if [[ -n $TIBvers ]]
  then
    touch "$rpmDir/tyk-identity-broker-$TIBvers"
  fi
  if [[ -n $syncVers ]]
  then
    touch "$rpmDir/tyk-sync-$syncVers"
  fi
}


# list the version relationships we know about
function listversions {
  typeset gwVers; typeset version
  for version in $(echo ${!GATEWAY[@]} | xargs -n 1 | sort -rV)
  do
    gwVers=${GATEWAY[$version]}
    echo "Version:   $version"
    echo "    Gateway:   $gwVers"
    [[ ${DASHBOARD[$gwVers]+_} ]] && echo "    Dashboard: ${DASHBOARD[$gwVers]}"
    [[ ${TIB[$gwVers]+_} ]] && echo "    TIB:       ${TIB[$gwVers]}"
    [[ ${PUMP[$gwVers]+_} ]] && echo "    Pump:      ${PUMP[$gwVers]}"
  done
}

# isolated to keep IFS from leaking
function loadVersions {
  typeset line; typeset IFS; typeset gwVers; typeset dshbVers; typeset pumpVers
  typeset TIBvers; typeset syncVers; typeset version
  line=$1
  IFS=,
  echo "$line" | read version gwVers dshbVers pumpVers TIBvers syncVers
  GATEWAY[$version]=$gwVers
  DASHBOARD[$gwVers]=$dshbVers
  PUMP[$gwVers]=$pumpVers
  TIB[$gwVers]=$TIBvers
  SYNC[$gwVers]=$syncVers
}

# Load the versions of the products that go together
function loadVersionFile {
  typeset line; typeset versionFile
  for line in $(awk 'NF && !/#/' $VERSIONFILE)
  do
    loadVersions "$line"
  done
}

# Report the details of a sandbox container
function getSandboxInfo {
  typeset index
  index=$1
  containerName=sandbox-$index
  echo $containerName \($(docker container inspect -f '{{ .State.Status }}' $containerName)\)
  docker container inspect -f '{{ range $k, $v := .Config.Labels }}{{ $k }}: {{ println $v }}{{ end }}' $containerName | grep sandbox
  echo
}

# Loop through all the sandboxes
function getAllSandboxInfo {
  typeset existing
  typeset index
  existing=$(docker container list -a | awk '$NF ~ /^sandbox-/ {print $NF}' | cut -d \- -f2 | sort -n)
  for index in $existing
  do
    getSandboxInfo $index
  done
}

# find the the highest image revision and add one
function nextFreeImageRev {
  typeset version
  typeset existing
  typeset biggest
  version=$1
  existing=$(docker image list tyk-sandbox | awk '$2 ~ /'$version'/ {print $2}' | sort -V | tail -1)
  if [[ -z $existing ]]
  then
    echo 1
  else
    biggest=$(echo $existing | cut -d- -f2)
    let biggest=biggest+1
    echo $biggest
  fi
}

# find the next container index that's unused
function nextFreeContainer {
  typeset existing
  typeset i
  existing=$(docker container list -a | awk '$NF ~ /^sandbox-/ {print $NF}')
  for i in $(seq 1 1000) 
  do
    test="sandbox-$i"
    if ! echo $existing | grep -qw $test
    then
      echo $i
      break
    fi
  done
}

# build all images
function buildAllImages {
  typeset version
  for version in $(echo ${!GATEWAY[@]} | xargs -n 1 | sort -rV)
  do
    echo "[INFO]Building $version"
    buildImage -v $version
  done
}

# invoke docker image build with all the right details
function buildImage {
  typeset arg; typeset tykVersion; typeset tykVersion
  typeset rpm; typeset packageRev; typeset arg; typeset OPTARG
  while getopts :lv:r: arg
  do
    case $arg in 
      l)
        listversions
        exit 0
        ;;
      r)
        packageRev=$OPTARG
        ;;
      v)
        tykVersion=$OPTARG
        ;;
      :)
        echo "Option -$OPTARG requires an arguement."
        exit 1
        ;;
      \?)
        echo "Invalid option: -$OPTARG"
        exit 1
        ;;
    esac
  done
  if [[ -z $tykVersion ]]
  then
    echo "[FATAL]Must specify a version to build" 1>&2
    exit 1
  elif [[ $tykVersion == "ALL" ]]
  then
    buildAllImages
    return
  fi
  if [[ -z $packageRev ]]
  then
    packageRev=$( nextFreeImageRev $tykVersion )
  fi
  if docker image list tyk-sandbox | grep -qw $tykVersion-$packageRev
  then
    echo "[FATAL]Image version $tykVersion-$packageRev aready built" 1>&2
    return
  fi
  if ! docker image list tbi | grep -qw latest
  then
    cd "$SCRIPTDIR/tbi"
    docker image build --tag tbi:latest .
  fi
  cd "$SCRIPTDIR"
  touchRPMs $tykVersion
  docker image build --tag tyk-sandbox:$tykVersion-$packageRev .
}

# invoke docker container create and start with everything set
function createSandbox {
  typeset index; typeset list; typeset ticket; typeset tykVersion; typeset env_file
  typeset containerName; typeset arg; typeset offset; typeset hostFQDN; typeset dashboardPort; typeset gatewayPort
  typeset label; typeset dashboardURL; typeset gatewayURL; typeset TIBPort; typeset tibURL; typeset noBootstrap
  typeset arg; typeset OPTARG
  while getopts :ni:v:t: arg
  do
    case $arg in
      i)
        index=$OPTARG
        ;;
      n)
        noBootstrap=1
        ;;
      t)
        ticket="$OPTARG"
        ;;
      v)
        tykVersion=$OPTARG
        ;;
      :)
        echo "Option -$OPTARG requires an arguement."
        exit 1
        ;;
      \?)
        echo "Invalid option: -$OPTARG"
        exit 1
        ;;
    esac
  done

  if [[ -z $tykVersion ]]
  then
    tykVersion=latest
  fi

  if [[ -z $ticket ]]
  then
    ticket="N/A"
  fi

  if [[ -z $index ]]
  then
    index=$(nextFreeContainer)
  fi

  offset=$(($index-1))
  hostFQDN=$IP_addr
  dashboardPort=$(($DashboardBasePort+$offset))
  gatewayPort=$(($GatewayBasePort+$offset))
  containerName=sandbox-$index
  label=$containerName
  dashboardURL=http://$hostFQDN:$dashboardPort/
  gatewayURL=https://$hostFQDN:$gatewayPort/
  # only configure TIB if gateway version is in the 2 series
  if echo $tykVersion | egrep -q '^2'
  then
    TIBPort=$((4010+$offset))
    tibURL=http://$hostFQDN:$TIBPort/
  fi
  # Create a directory just for this version to hold plugins
  for dir in "$SandboxPluginDir" "$SandboxCertDir"
  do
    if [[ ! -d "$dir" ]]
    then
      mkdir -p "$dir"
    fi
  done
  if [[ $tykVersion != "latest" && ! -d $SandboxPluginDir/$tykVersion ]]
  then
    echo "[WARN]Creating $SandboxPluginDir/$tykVersion: It will be empty"
    mkdir -p $SandboxPluginDir/$tykVersion
  fi
  # load username, password and licence if they stored in ~/.tyk-sandbox
  if [[ -z $noBootstrap && -f ~/.tyk-sandbox ]]
  then
    env_file="--env-file $(\ls ~/.tyk-sandbox)"
  else
    env_file=""
  fi
  echo "[INFO]Creating container $containerName"
  docker container create --name $containerName \
    --publish $dashboardPort:3000 \
    --publish $gatewayPort:8080 \
    --env TYK_GW_PORT=$gatewayPort \
    --env TYK_GW_HOST=$hostFQDN \
    --env TYK_DSHB_HOST=$hostFQDN $env_file\
    --label sandbox.label=$label \
    --label sandbox.version=$tykVersion \
    --label sandbox.dashurl=$dashboardURL \
    --label sandbox.ticket="$ticket" \
    --label sandbox.gateurl=$gatewayURL \
    --label sandbox.index=$index \
    --volume $SandboxPluginDir/$tykVersion:/opt/tyk-plugins \
    tyk-sandbox:$tykVersion
  # --volume $SandboxCertDir:/opt/tyk-certificates
  if [[ $? -eq 0 ]]
  then
    echo "[INFO]Starting container $containerName"
    docker container start $containerName
    getSandboxInfo $index
  fi
}

# list the sandboxes in a standard format.
function listNames {
  typeset name; typeset list
  if [[ $1 == "ALL" ]]
  then
    docker container list -a | awk '$NF ~ /^sandbox-/ {print $NF}' | cut -d \- -f2 | sort -n
  else
    for name in $*
    do
      if echo $name | grep -iq sandbox-
      then
        name=$(echo $name | cut -d\- -f2)
      fi
      list="$list $name"
    done
    echo $list
  fi
}

if [[ $# -lt 1 ]]
then
  help
  exit 1
fi

# load the details of what version of what goes with what
loadVersionFile

case $1 in
  rm|stop|start|restart)
    action=$1
    shift
    for index in $(listNames $*)
    do
      docker container $action sandbox-$index
    done
    ;;
  build)
    shift
    # Create a docker image with the given parameters
    buildImage "$@"
    ;;
  create)
    shift
    # Create a docker sandbox with the given parameters
    createSandbox "$@"
    ;;
  info|list)
    if [[ $# -gt 1 ]]
    then
      shift
      # Inspect the details of the given container
      for index in $(listNames $*)
      do
        getSandboxInfo $index
      done
    else
      # Inspect the details of all exiting containers
      getAllSandboxInfo
    fi
    ;;
  shell|bash)
    # Give a shell in the given container
    shift
    for index in $(listNames $*)
    do
      docker container exec -it sandbox-$index bash
    done
    ;;
  image*)
    # list the tyk-sandbox docker images
    # note the almost magical pipe feature of awk used here.
    docker image list tyk-sandbox | awk '/REPOSITORY/ {print $0; next} {print $0 | "sort -Vr"}'
    ;;
  help)
    help
    ;;
  *)
    echo "[FATAL]Unknown option \"$1\"" 1>&2
    help
esac
